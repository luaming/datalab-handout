## bitXor
### 函数实现：

```c
int bitXor(int x, int y) {
  return (~(x&y)&~(~x&~y));
}
```

### 函数分析：

这个函数的目的是实现位异或操作（XOR），即 `x ^ y` ，但只使用 `~`（位非）和 `&`（位与）运算符。

- 考虑异或的定义：当两个位不同（一个是1，另一个是0）时，结果为1；当两个位相同（都是0或都是1）时，结果为0。
- `~(x & y)` 表示在x和y中相应位不同时都是1的情况，即至少有一个是0。
- `~(~x & ~y)` 表示在x和y中相应位不同时都是0的情况，即至少有一个是1。
- `~(x&y)&~(~x&~y)` 结合了上述两个条件，仅在x和y在相应位上一个为1另一个为0时产生1，符合异或的定义。

## copyLSB
### 函数实现：

```c
int copyLSB(int x) {
  return (x << 31) >> 31;
}
```

### 函数分析：

此函数的目的是将`x`的最低有效位复制到所有位上。

- 操作`x << 31`将`x`的最低有效位移至最高位的位置。此操作的结果是最高位包含`x`的最低有效位，而其余位均为0。
- 通过 `(x << 31) >> 31` 右移31位，这个操作会将最高位复制到所有的位上。这是因为C语言中对带符号整数的右移是算术右移，它将保留最高位的值，并将其复制到所有右移过程中新出现的位上。

## isEqual
### 函数实现：

```c
int isEqual(int x, int y) {
  return !(x ^ y);
}
```

### 函数分析：

这个函数的目标是检测两个整数`x`和`y`是否相等，并返回1（相等）或0（不相等）。

- 如果`x`和`y`完全相同，`x ^ y`的结果将是0，`!(x ^ y)`将返回1。
- 如果`x`和`y`不相等，`!(x ^ y)`将返回0。

## bitMask
### 函数实现：

```c
int bitMask(int highbit, int lowbit) {
    int a = ~(0);
    int n = a << lowbit;
    //int m = ~(a << (highbit + 1));
    int m = a + (0x2 << highbit);
    return m & n;
}
```

### 函数分析：

这个函数的目标是生成一个位掩码，其中从`lowbit`到`highbit`的位是1，其余位是0。

- `int a = ~(0);` 生成一个全1的掩码。
- `int n = a << lowbit;` 将全1掩码左移`lowbit`位，从而在`lowbit`及其以上位设为1，以下位设为0。
- `int m = ~(a << (highbit + 1));` 先将全1掩码左移`highbit + 1`位，然后取反，结果是从0位到`highbit`位为1，其余位为0。
> 本行代码可优化为`int m = a + (0x2 << highbit);` 先将0x2(00...0010)左移`highbit`位，然后加到`a`上。由于`a`是全1掩码，这个操作可以将`highbit`位变为0，其余位保持为1。
- `return m & n;` 最后，通过`m & n`操作结合`m`和`n`掩码，生成最终的位掩码。这个掩码在`lowbit`和`highbit`之间的位是1，其余位是0。如果`lowbit`大于`highbit`，则掩码结果将自动变为全0，因为`n`和`m`在此情况下没有重叠的1位。

## tmax
### 函数实现：

```c
int tmax(void) {
  return ~(1 << 31);
}
```

### 函数分析：

这个函数返回最大的二进制补码整数。

- 在二进制补码表示中，当符号位为0，其余位全部为1时，表示的是最大的正整数。
- `1 << 31` 将数字1左移31位，结果是一个二进制数，其中只有最高位是1，其余位是0。这个值表示32位整数中的最小负数。
- `~(1 << 31)` 将上述结果取反。由于只有最高位是1，取反后最高位变为0，其余31位变为1。这正是32位二进制补码表示中的最大正整数。

## isNonNegative
### 函数实现：

```c
int isNonNegative(int x) {
  return !(x >> 31);
}
```

### 函数分析：

此函数用于判断整数`x`是否非负。

- 在二进制补码表示法中，一个整数的最高位是符号位：0表示正数或0，1表示负数。
- `x >> 31` 将`x`向右移动31位，使得最初的符号位成为唯一的位。如果`x`是正数或0，移位后的结果是0；如果`x`是负数，结果是-1（即二进制表示全为1）。
- `!` 操作符取反结果。如果移位后的结果是0（即`x`是非负的），`!`操作将返回1；如果结果是-1（即`x`是负数），`!`操作将返回0。

## addOK
### 函数实现：

```c
int addOK(int x, int y) {
  int s = x + y;
  //return !!(((x ^ y) | ~(y ^ s)) >> 31);
  return !(((x ^ s) & (y ^ s)) >> 31);
}
```

### 函数分析：

这个函数的目的是判断两个整数`x`和`y`相加是否会导致溢出。

- `int s = x + y;` 计算`x`和`y`的和。
- 当且仅当 x 和 y 的符号相同（两个正数或两个负数相加）但与结果s的符号不同（表示一个正数加一个正数得到负数，或一个负数加一个负数得到正数），这时发生溢出。
- `(x ^ y) | ~(y ^ s)`这个表达式结合了两个条件。只要x和y的符号不同，或者y和s的符号相同，结果的最高位将是1。换句话说，当且仅当x和y符号相同，且与s不同（这时发生溢出），此表达式的最高位才是0。
>可做以下优化：
>- 这两个条件可以通过检查 `x ^ s` 和 `y ^ s`的最高位是否都是1来判断。如果`x`和`s`的符号不同，则`x ^ s`的最高位为1；同理，如果`y`和`s`的符号不同，则`y ^ s`的最高位为1。只有当 `x`和`s`的符号不同且`y`和`s`的符号也不同时，`((x ^ s) & (y ^ s))`的结果才为非零，即最高位为1，表明溢出。
- 将上述结果向右移动31位，将符号位移动到最低位，再取反。如果最低位为1（表示溢出），`!`操作后返回0；如果最低位为0（表示无溢出），`!`操作后返回1。

## isLess
### 函数实现：

```c
int isLess(int x, int y) {
  int a = ((~(x ^ y)) & (x + (~y) + 1));
  int b = x & (~y);
  return ((a | b) >> 31) & 1;
}
```

### 函数分析：

此函数的目的是判断x是否小于y。

- `x + (~y) + 1`实际上计算的是`x - y`。
- 仅有两种情况使得`x < y`。第一种情况，`x`和`y`同号，此时两数减法不会溢出，则`x - y < 0`即可代表`x < y`。第二种情况，`x`和`y`异号，则只可能`x`为负数`y`为正数。
- 符号位算术右移31位，然后与1进行与运算，就可以仅保留移动后的最低位。

### 钻系统判定空子的函数实现：

```c
int isLess(int x, int y) {
  long long longx = x;
  return (1 + ((y + ~longx) >> 63)) & 1;
}
```

### 函数分析：

- `y + (~x) + 1`实际上计算的是`y - x`。
- `long long`类型避免在计算`x - y`时可能发生的溢出。

## float_neg
### 函数实现：

```c
unsigned float_neg(unsigned uf) {
    if (((uf & 0x7FFFFFFF) > 0x7F800000)) {
        return uf;
    }
    return uf ^ 0x80000000;
}
```

### 函数分析：

这个函数的目标是返回单精度浮点数`uf`的相反数的位级表示。当`uf`为NaN时，函数返回原值。

 - 单精度浮点数由1个符号位，8个指数位，和23个尾数位组成。NaN的特点是指数全为1，且尾数不为0。`uf & 0x7FFFFFFF`屏蔽掉符号位，如果结果大于`0x7F800000`（指数全为1，尾数至少有1位是1），则`uf`是NaN。

- 如果`uf`不是NaN，函数通过`uf`与`0x80000000`进行异或操作来更改符号位。这个值的二进制表示是有一个1在最高位，其他位全为0，因此异或操作会翻转符号位，而保留其他位不变。

## float_half
### 函数实现：

```c
unsigned float_half(unsigned uf) {
    unsigned sign = uf & 0x80000000;      
    unsigned exponent = uf & 0x7F800000;  
    unsigned fraction = uf & 0x007FFFFF; 
    if (exponent == 0x7F800000) {
        return uf;
    }
    else if (exponent == 0) {
        fraction >>= 1;
        fraction += (uf & 0x3) == 0x3;
    } 
    else {
        if (exponent == 0x00800000) {
            fraction >>= 1;
            fraction += (uf & 0x3) == 0x3;
            fraction |= 0x00400000;
        }
        exponent -= 0x00800000;
    }
    return sign | exponent | fraction;
}
```

### 函数分析：

这个函数的目的是返回单精度浮点数`uf`的一半的位级表示。当输入为NaN时，函数返回原值。

- `sign = uf & 0x80000000;` 提取符号位。`exponent = uf & 0x7F800000;` 提取指数部分。`fraction = uf & 0x007FFFFF;` 提取尾数部分。
- 如果`exponent == 0x7F800000`（指数位全1），表示`uf`是NaN或无穷大，直接返回原值。
- 如果`exponent == 0`，则`uf`是非规格化值。此时，右移尾数一位来实现除以2，如果`uf`的最低两位是`0x3`（即最低两位都为1），则进行舍入操作。
- 对于指数最小（指数为`0x00800000`的规格化值，它将转为非规格化值。将指数部分归零（if执行之后，指数位减去指数的最小单位`0x00800000`），还需要尾数右移一位，再高位补1，最后考虑舍入。
- 对其他规格化值，指数位减去指数的最小单位`0x00800000`，即指数位减1来实现除以2。
- `return sign | exponent | fraction;` 重组符号位、指数部分和尾数部分，得到最终结果。

### 究极简化的函数实现:

```c
unsigned float_half(unsigned uf) {
    unsigned half = uf >> 1;
    int sign = 0;
    switch (uf >> 23){
        case (0x000):
        case (0x001): 
            break;
        case (0x100):
        case (0x101):         
            sign = 0xc0000000;
            break; 
        case (0x0ff):
        case (0x1ff): 
            return uf;
        default: 
            return uf - 0x800000;

    return sign ^ (half + (uf & half & 1));
    }
}
```

### 函数分析：
- `uf >> 23`取符号位和指数位并做无符号扩展。
- `0x000`表示`uf`是非规格化值，那么uf的一半即尾数除以2，也即`uf`整体右移一位（因为高9位都是0，尾数的右移就是整体的右移），再利用`(uf & half & 1)`来处理舍入。`0x001`表示`uf`是指数位为1的规格化值，它将转为非规格化值。将指数部分归零，还需要尾数右移一位，再高位补1（也即`uf`整体右移一位），再利用`(uf & half & 1)`来处理舍入。0的异或不改变原值。
> `(uf & half & 1)`用来处理舍入:如果`uf`和`half`的最低有效位都为 1，即`uf`尾数的最后两位都是1，那么结果加1。
- `0x100`和`0x101`和上一条相似，只需额外考虑负号。用`0xc0000000`（`sign`）异或把`half`的最高位改为1，次高位(`uf`符号位挪过来的1)改为0。
- `0x0ff`和`0x1ff`表示`uf`是正负无穷或NaN，直接返回原值。
- 其余都是一般情况，`uf`减去指数的最小单位`0x00800000`，即指数位减1来实现除以2。